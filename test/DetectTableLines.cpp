// ConsoleApplication1.cpp : Defines the entry point for the console application.
//


#include <opencv2/opencv.hpp>
#include <iostream>
#include<opencv2/video/video.hpp>
#include<opencv2/video/background_segm.hpp>


using namespace std;
using namespace cv;

//global variables

Mat frame;
Mat blur_frame;
Mat HSVframe;
Mat gray;
Mat mask;
Mat fgMaskMOG; //fg mask generated by MOG method
Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
Mat canny_output; //countours
Ptr<BackgroundSubtractor> pMOG; //MOG Background subtractor
Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
vector<Mat> channels(3);

//Find point (x,y) where two parameterized lines intersect :p Returns 0 if lines are parallel 
int parametricIntersect(float r1, float t1, float r2, float t2, int *x, int *y) {
	float ct1 = cosf(t1);     //matrix element a
	float st1 = sinf(t1);     //b
	float ct2 = cosf(t2);     //c
	float st2 = sinf(t2);     //d
	float d = ct1*st2 - st1*ct2;        //determinative (rearranged matrix for inverse)
	if (d != 0.0f) {
		*x = (int)((st2*r1 - st1*r2) / d);
		*y = (int)((-ct2*r1 + ct1*r2) / d);
		return(1);
	}
	else { //lines are parallel and will NEVER intersect!
		return(0);
	}
}


int main() {
    
    // Create a VideoCapture object and open the input file
    // If the input is the web camera, pass 0 instead of the video file name
    VideoCapture cap("pool2.mp4");
    
    // Default resolution of the frame is obtained.The default resolution is system dependent.
    int frame_width = cap.get(CV_CAP_PROP_FRAME_WIDTH);
    int frame_height = cap.get(CV_CAP_PROP_FRAME_HEIGHT);
    
    // Define the codec and create VideoWriter object.The output is stored in 'outcpp.avi' file.
    //VideoWriter video("outcpp.avi",CV_FOURCC('M','J','P','G'),10, Size(frame_width,frame_height));
    
    
    // Check if camera opened successfully
    if (!cap.isOpened()) {
        cout << "Error opening video stream or file" << endl;
        return -1;
    }
    
    bool Play = true;
    
    while (1) {
        
        // Capture frame-by-frame
        if (Play){
            cap >> frame;
            
            // If the frame is empty, break immediately
            if (frame.empty())
                break;
            


            // convert to green chromaticity


            Mat gc = Mat(Size(frame.cols, frame.rows), CV_8UC1);
            for (int i = 0; i < frame.rows; ++i)
            {
                for (int j = 0; j < frame.cols; ++j)
                {
                    Vec3b RGB = frame.at<Vec3b>(i, j);
                    int G = RGB[1];
                    int sRGB = int(RGB[0]) + int(RGB[1]) + int(RGB[2]);
                    float g = float(G) / float(sRGB);
                    gc.at<char>(i, j) = char(g * 255.0f);
                }
            }

            Mat bg;

            cout << gc;

            blur(gc,gc, Size(5,5));

            cout << gc;

		    threshold(gc, bg, 0, 255, CV_THRESH_BINARY | CV_THRESH_OTSU);

		    //Mat kernel = Mat::ones(Size(5, 5), CV_8UC1);
		    //dilate(bg, bg, kernel);


            //Detect contours avec FindContours
            vector<vector<Point> > contours;
            vector<Vec4i> hierarchy;
            findContours(bg, contours, hierarchy, CV_RETR_TREE, CV_CHAIN_APPROX_SIMPLE, Point(0, 0) );
            
            
            
            
            // Approximate contours to polygons + get bounding rects and circles
            // Draw polygonal contour + bonding rects + circles // Select right balls
            
            vector<vector<Point> > contours_poly( contours.size() );
            //vector<Point2f>center( contours.size() );
            //vector<float>radius( contours.size() );
            //int maxRadius = 60;
            //int MinRadius = 8;
            //Scalar color_ball = Scalar(255,255,255);
            Scalar color_table = Scalar(100,10,10);
            Mat temp = Mat::zeros( frame.size(), CV_8UC3);
            Mat drawing = Mat::zeros(frame.size(), CV_8UC1);
            vector<vector<Point> >hull( contours.size() );
            int largest_area=0;
            int largest_contour_index=0;
            
            for( int i = 0; i < contours.size(); i++ ){
                convexHull(Mat(contours[i]), hull[i]);
                //approxPolyDP(hull[i], contours_poly[i], 3, true );
                //minEnclosingCircle( contours_poly[i], center[i], radius[i] );
                //double rad =radius[i];
                double area=contourArea(hull[i],false);
                if(area>largest_area){
                    largest_area=area;
                    largest_contour_index=i;}
                //if (rad<maxRadius and rad>MinRadius){
                    //drawContours( drawing, contours_poly, i, color, 1, 8, vector<Vec4i>(), 0,Point() );
                    //circle(drawing, center[i], (int)radius[i], color_ball, 2, 8, 0 );
                    //circle(frame, center[i], (int)radius[i], color_ball, 2, 8, 0 );
                    //}
            }
            
            drawContours(frame, hull, largest_contour_index, color_table, 3, 8, vector<Vec4i>(), 0, Point());
            drawContours(drawing, hull, largest_contour_index, Scalar(255), 2, 8, vector<Vec4i>(), 0, Point());

            //drawContours(temp, hull, largest_contour_index, Scalar(1,1,1), -1, 8, vector<Vec4i>(), 0, Point());
            //frame = frame.mul(temp);
            //drawContours(frame, hull, largest_contour_index, Scalar(1,1,1), 2, 8, vector<Vec4i>(), 0, Point());

            
            //vector<Vec4i> lines;
            //HoughLinesP(drawing, lines, 1, 1*CV_PI/180, 10 , 30, 100);
            //for(size_t i = 0; i < lines.size(); i++ ){
            //      line(frame, Point(lines[i][0], lines[i][1]),Point(lines[i][2], lines[i][3]), Scalar(200,40,40), 3, 8 );
            //   }
            //
            //cout << lines.size();

            // detect lines
		    vector<Vec2f> lines;
		    HoughLines(drawing, lines, 1, 1*CV_PI / 180, 480, 0, 0);

            /// Show the result
            for( size_t i = 0; i < lines.size(); i++ )
                {
                float r = lines[i][0], t = lines[i][1];
                double cos_t = cos(t), sin_t = sin(t);
                double x0 = r*cos_t, y0 = r*sin_t;
                double alpha = 1000;

                Point pt1( cvRound(x0 + alpha*(-sin_t)), cvRound(y0 + alpha*cos_t) );
                Point pt2( cvRound(x0 - alpha*(-sin_t)), cvRound(y0 - alpha*cos_t) );
                line(frame, pt1, pt2, Scalar(255,0,0), 3, LINE_AA);

                for (size_t j = 0; j < lines.size(); ++j)
				{
					int x, y;
					int r = parametricIntersect(lines[i][0], lines[i][1], lines[j][0], lines[j][1], &x, &y);
					if (r != 0)
					{
						if (x > 0 && x < frame.cols &&
							y > 0 && y < frame.rows)
						{
							circle(frame, Point(x, y), 10, Scalar(255, 0, 0), 2);
						}
					}
				}
                }

            
            //Display_video

           // Mat aa = bg/255.;

            //frame = aa*frame;

            imshow("frame", gc);
        
            
        }
        
        //Press Space to pause
        char b = (char)waitKey(1);
        if (b == 'p')
            Play = !Play;
        
        
        // Press  ESC on keyboard to exit
        char c = (char)waitKey(25);
        if (c == 27)
            break;
        
    }
    
    // When everything done, release the video capture object
    cap.release();
    //video.release();
    
    // Closes all the frames
    destroyAllWindows();
    
    return 0;
}

