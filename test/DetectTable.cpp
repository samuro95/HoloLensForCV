// ConsoleApplication1.cpp : Defines the entry point for the console application.
//


#include <opencv2/opencv.hpp>
#include <iostream>
#include<opencv2/video/video.hpp>
#include<opencv2/video/background_segm.hpp>


using namespace std;
using namespace cv;

//global variables

Mat frame;
Mat blur_frame;
Mat HSVframe;
Mat gray;
Mat mask;
Mat fgMaskMOG; //fg mask generated by MOG method
Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
Mat canny_output; //countours
Ptr<BackgroundSubtractor> pMOG; //MOG Background subtractor
Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
vector<Mat> channels(3);


int main() {
    
    // Create a VideoCapture object and open the input file
    // If the input is the web camera, pass 0 instead of the video file name
    VideoCapture cap("pool_hololens.mp4");
    
    // Default resolution of the frame is obtained.The default resolution is system dependent.
    int frame_width = cap.get(CV_CAP_PROP_FRAME_WIDTH);
    int frame_height = cap.get(CV_CAP_PROP_FRAME_HEIGHT);

    
    // Check if camera opened successfully
    if (!cap.isOpened()) {
        cout << "Error opening video stream or file" << endl;
        return -1;
    }
    
    bool Play = true;
    
    while (1) {
        
        // Capture frame-by-frame
        if (Play){
            cap >> frame;
            
            // If the frame is empty, break immediately
            if (frame.empty())
                break;
            
            // convert to green chromaticity
            Mat gc = Mat(Size(frame.cols, frame.rows), CV_8UC1);
            for (int i = 0; i < frame.rows; ++i)
            {
                for (int j = 0; j < frame.cols; ++j)
                {
                    Vec3b RGB = frame.at<Vec3b>(i, j);
                    int G = RGB[1];
                    int sRGB = int(RGB[0]) + int(RGB[1]) + int(RGB[2]);
                    float g = float(G) / float(sRGB);
                    gc.at<char>(i, j) = char(g * 255.0f);
                }
            }

            Mat bg;
		    threshold(gc, bg, 0, 255, CV_THRESH_BINARY | CV_THRESH_OTSU);



		    //Mat kernel = Mat::ones(Size(5, 5), CV_8UC1);
		    //dilate(bg, bg, kernel);



            /*

            Mat gray;
		    cvtColor(frame, gray, CV_BGR2GRAY);

            Mat sx, sy;
            Sobel(gray, sy, CV_8UC1, 0, 1, 5, 0.4);
            Sobel(gray, sx, CV_8UC1, 1, 0, 5, 0.4);
            convertScaleAbs(sx, sx);
            convertScaleAbs(sy, sy);
            addWeighted(sx, 0.5, sy, 0.5, 0, gray);
            threshold(gray, gray, 0, 255, CV_THRESH_BINARY | CV_THRESH_OTSU);
            gray -= fg;

            
            

            // detect lines
		    vector<Vec2f> lines;
		    HoughLines(fg, lines, 1, CV_PI / 180, 60, 0, 0);

            // cluster lines
		    Mat labels, centers;
		    kmeans(lines, 9, labels, TermCriteria(TermCriteria::EPS + TermCriteria::COUNT, 10, 1.0),
			3, KMEANS_PP_CENTERS, centers);

            // cluster lines based on angle only
            vector<float> rhos, thetas;
            for (size_t i = 0; i < centers.rows; ++i)
            {
                float rho = centers.at<Vec2f>(i, 0)[0];
                float theta = centers.at<Vec2f>(i, 0)[1];
                rhos.push_back(rho);
                thetas.push_back(theta);
            }
            Mat labelsTheta, centersTheta;
            kmeans(thetas, 2, labelsTheta, TermCriteria(TermCriteria::EPS + TermCriteria::COUNT, 10, 1.0),
                3, KMEANS_PP_CENTERS, centersTheta);

            // draw cluster center lines
            int n0 = 0, n1 = 0;
            vector<float> rhos0, thetas0, rhos1, thetas1;
            for (size_t i = 0; i < centers.rows; ++i)
            {
                float rho = centers.at<Vec2f>(i, 0)[0];
                float theta = centers.at<Vec2f>(i, 0)[1];
                int label = labelsTheta.at<int>(i, 0);
                if (label == 0)
                {
                    rhos0.push_back(rho);
                    thetas0.push_back(theta);
                }
                else
                {
                    rhos1.push_back(rho);
                    thetas1.push_back(theta);
                }

                if (label == 1)
                {
                    ++n1;
                }
                else
                {
                    ++n0;
                }

                Point pt1, pt2;
                double a = cos(theta), b = sin(theta);
                double x0 = a*rho, y0 = b*rho;
                pt1.x = cvRound(x0 + 2000 * (-b));
                pt1.y = cvRound(y0 + 2000 * (a));
                pt2.x = cvRound(x0 - 2000 * (-b));
                pt2.y = cvRound(y0 - 2000 * (a));
                line(frame, pt1, pt2, Scalar(label * 255, 255, 255 - (label * 255)), 3, CV_AA);
            }

            


            
            blur(frame,blur_frame, Size(5,5));
            
            cvtColor(blur_frame, HSVframe, CV_BGR2HSV);
            split(HSVframe,channels);
            Mat hframe;
            hframe=channels[0];
            
            
            
            //calculate mean Hue channel
            Scalar tempval = mean (hframe);
            float Hmean=tempval.val[0];
            
            //threshold on the Hue channel
            float minthres = Hmean - 10;
            float maxthres = Hmean + 10;
            Scalar mintable = {minthres,0,0};
            Scalar maxtable = {maxthres,255,255};
            Mat threshold;
            inRange(HSVframe,mintable,maxtable,threshold);
            
            // Create a structuring element
            int erosion_size = 4;
            Mat element = getStructuringElement(cv::MORPH_CROSS,
                                                cv::Size(2 * erosion_size + 1, 2 * erosion_size + 1),
                                                cv::Point(erosion_size, erosion_size) );
            
            // Apply erosion or dilation on the image
            erode(threshold,threshold,element);
            dilate(threshold,threshold,element);
            

            */

            //calculate mean Hue channel
            Mat hframe;
            Scalar tempval = mean (hframe);
            float Hmean=tempval.val[0];

            //Detect contours avec FindContours
            vector<vector<Point> > contours;
            vector<Vec4i> hierarchy;
            findContours(bg, contours, hierarchy, CV_RETR_TREE, CV_CHAIN_APPROX_SIMPLE, Point(0, 0) );
            
            
            
            
            // Approximate contours to polygons + get bounding rects and circles
            // Draw polygonal contour + bonding rects + circles // Select right balls
            
            vector<vector<Point> > contours_poly( contours.size() );
            vector<Point2f>center( contours.size() );
            vector<float>radius( contours.size() );
            int maxRadius = 60;
            int MinRadius = 8;
            Scalar color_ball = Scalar(255,255,255);
            Scalar color_table = Scalar(100,10,10);
            Mat temp = Mat::zeros( frame.size(), CV_8UC3);
            Mat drawing = Mat::zeros(frame.size(), CV_8UC1);
            vector<vector<Point> >hull( contours.size() );
            int largest_area=0;
            int largest_contour_index=0;
            
            for( int i = 0; i < contours.size(); i++ ){
                convexHull(Mat(contours[i]), hull[i]);
                approxPolyDP(hull[i], contours_poly[i], 3, true );
                minEnclosingCircle( contours_poly[i], center[i], radius[i] );
                double rad =radius[i];
                double area=contourArea(hull[i],false);
                if(area>largest_area){
                    largest_area=area;
                    largest_contour_index=i;}
                if (rad<maxRadius and rad>MinRadius){
                    //drawContours( drawing, contours_poly, i, color, 1, 8, vector<Vec4i>(), 0,Point() );
                    circle(drawing, center[i], (int)radius[i], color_ball, 2, 8, 0 );
                    circle(frame, center[i], (int)radius[i], color_ball, 2, 8, 0 );
                    }
            }
            
            //drawContours(frame, hull, largest_contour_index, color_table, 3, 8, vector<Vec4i>(), 0, Point());
            drawContours(drawing, hull, largest_contour_index, Scalar(255), 2, 8, vector<Vec4i>(), 0, Point());
            drawContours(temp, hull, largest_contour_index, Scalar(1,1,1), -1, 8, vector<Vec4i>(), 0, Point());
            frame = frame.mul(temp);
            drawContours(frame, hull, largest_contour_index, Scalar(1,1,1), 2, 8, vector<Vec4i>(), 0, Point());

            
            //vector<Vec4i> lines;
            //HoughLinesP(drawing, lines, 1, 1*CV_PI/180, 10 , 30, 100);
            //for(size_t i = 0; i < lines.size(); i++ ){
            //      line(frame, Point(lines[i][0], lines[i][1]),Point(lines[i][2], lines[i][3]), Scalar(200,40,40), 3, 8 );
            //   }
            //
            //cout << lines.size();

            // detect lines
		    vector<Vec2f> lines;
		    HoughLines(drawing, lines, 1, 1*CV_PI / 180, 480, 0, 0);

            /// Show the result
            for( size_t i = 0; i < lines.size(); i++ )
                {
                float r = lines[i][0], t = lines[i][1];
                double cos_t = cos(t), sin_t = sin(t);
                double x0 = r*cos_t, y0 = r*sin_t;
                double alpha = 1000;

                Point pt1( cvRound(x0 + alpha*(-sin_t)), cvRound(y0 + alpha*cos_t) );
                Point pt2( cvRound(x0 - alpha*(-sin_t)), cvRound(y0 - alpha*cos_t) );
                line(frame, pt1, pt2, Scalar(255,0,0), 3, LINE_AA);

                for (size_t j = 0; j < lines.size(); ++j)
				{
					int x, y;
					int r = parametricIntersect(lines[i][0], lines[i][1], lines[j][0], lines[j][1], &x, &y);
					if (r != 0)
					{
						if (x > 0 && x < frame.cols &&
							y > 0 && y < frame.rows)
						{
							circle(frame, Point(x, y), 10, Scalar(255, 0, 0), 2);
						}
					}
				}
                }

                //TODO : select the right circle if several detected 

            
            


            /*
            // cluster lines
		    Mat labels, centers;
		    kmeans(lines, 9, labels, TermCriteria(TermCriteria::EPS + TermCriteria::COUNT, 10, 1.0),
			3, KMEANS_PP_CENTERS, centers);

            // cluster lines based on angle only
            vector<float> rhos, thetas;
            for (size_t i = 0; i < centers.rows; ++i)
            {
                float rho = centers.at<Vec2f>(i, 0)[0];
                float theta = centers.at<Vec2f>(i, 0)[1];
                rhos.push_back(rho);
                thetas.push_back(theta);
            }
            Mat labelsTheta, centersTheta;
            kmeans(thetas, 2, labelsTheta, TermCriteria(TermCriteria::EPS + TermCriteria::COUNT, 10, 1.0),
                3, KMEANS_PP_CENTERS, centersTheta);

            // draw cluster center lines
            int n0 = 0, n1 = 0;
            vector<float> rhos0, thetas0, rhos1, thetas1;
            for (size_t i = 0; i < centers.rows; ++i)
            {
                float rho = centers.at<Vec2f>(i, 0)[0];
                float theta = centers.at<Vec2f>(i, 0)[1];
                int label = labelsTheta.at<int>(i, 0);
                if (label == 0)
                {
                    rhos0.push_back(rho);
                    thetas0.push_back(theta);
                }
                else
                {
                    rhos1.push_back(rho);
                    thetas1.push_back(theta);
                }

                if (label == 1)
                {
                    ++n1;
                }
                else
                {
                    ++n0;
                }

                Point pt1, pt2;
                double a = cos(theta), b = sin(theta);
                double x0 = a*rho, y0 = b*rho;
                pt1.x = cvRound(x0 + 2000 * (-b));
                pt1.y = cvRound(y0 + 2000 * (a));
                pt2.x = cvRound(x0 - 2000 * (-b));
                pt2.y = cvRound(y0 - 2000 * (a));
                line(frame, pt1, pt2, Scalar(label * 255, 255, 255 - (label * 255)), 3, CV_AA);
            }
            
           */

           

            //Display_video
            //imshow("Detected Lines", drawing2);
            //imshow("drawing", drawing);
            //imshow("contours2", contours2);
            //imshow("hframe", hframe);
            //imshow("threshold", threshold);
            imshow("frame", bg);
            
            // Write the frame into the file 'outcpp.avi'
            //video.write(frame);

            
            
        }
        
        //Press Space to pause
        char b = (char)waitKey(1);
        if (b == 'p')
            Play = !Play;
        
        
        // Press  ESC on keyboard to exit
        char c = (char)waitKey(25);
        if (c == 27)
            break;
        
    }
    
    // When everything done, release the video capture object
    cap.release();
    //video.release();
    
    // Closes all the frames
    destroyAllWindows();
    
    return 0;
}

